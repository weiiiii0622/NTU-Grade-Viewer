import hashlib
import math
import re
from abc import ABC
from typing import Annotated, Iterable, Optional, TypeAlias

from fastapi.exceptions import RequestValidationError
from pydantic import (
    AfterValidator,
    BaseModel,
    Field,
    ValidationError,
    field_validator,
    model_validator,
    validator,
)

# ---------------------------------- Course ---------------------------------- #


Id1: TypeAlias = Annotated[
    str,
    Field(
        # pattern=r"^.+?\d+$",
        description="'èª²è™Ÿ', e.g. 'CSIE1212'"
    ),
]  #
Id2: TypeAlias = Annotated[
    str,
    Field(
        # pattern=r"^.{3}\s.{5}$",
        description="'èª²ç¨‹è­˜åˆ¥ç¢¼', e.g. '902 10750'. Note the space character.",
    ),
]


class Course(BaseModel):
    id1: Id1
    id2: Id2
    title: str


# ----------------------------------- Grade ---------------------------------- #


# ? Change to this def. because I cannot fix openapi tuple issueðŸ¥²
def validate_semester(s: str):
    a, b = list(map(int, s.split("-")))
    if 130 >= a >= 90 and 2 >= b >= 1:
        return s
    raise ValidationError()


Semester = Annotated[
    str, Field(description="semester", pattern=r"^\d+-\d+$"), AfterValidator(validate_semester)
]


# A+: 9, A: 8, ..., F: 0
GRADES = ("F", "C-", "C", "C+", "B-", "B", "B+", "A-", "A", "A+")
GRADE_MAP = {grade: i for grade, i in enumerate(GRADES)}
GRADE_MAP_INV = {i: grade for grade, i in enumerate(GRADES)}

GradeInt: TypeAlias = Annotated[
    int,
    Field(
        ge=0,
        lt=len(GRADES),
        description="An integer between [0, 9], representing a grade. Example: 0 -> F, 9 -> A+.",
    ),
]


def validate_grade_str(s: str):
    if s in GRADES:
        return s
    raise ValidationError()


GradeStr: TypeAlias = Annotated[str, AfterValidator(validate_grade_str)]


class GradeBase(ABC, BaseModel):

    # course_id1: Id1
    course: Course
    semester: Semester = Field(description="Semester between 90-1 ~ 130-2", examples=["111-2"])

    # TODO: use scraper to get lecturer
    lecturer: str = Field(
        description="The lecturer.", examples=["æž—è»’ç”°"], default=''
    )  # ! this can not be obtained from page

    # TODO: consider using default ''
    class_id: str = Field(description="'ç­æ¬¡'", examples=["01"], default='')


# --------------------------------- GradeInfo -------------------------------- #


class GradeUpdate(GradeBase):
    """
    Grade information extracted from user page submited. The values are between 0~100.
    """

    grade: GradeStr
    dist: tuple[float, float, float]  # lower, same, higher

    @validator("dist")
    def valid_dist(cls, v: tuple[float, float, float]):
        if math.isclose(sum(v), 100, abs_tol=1) and len(v) != 3:
            raise ValidationError()
        return v


# ------------------------------- GradeElement ------------------------------- #


class Segment(BaseModel):
    """
    The distribution in the range [l, r].
    """

    l: GradeInt
    r: GradeInt
    value: float = Field(description="A float in [0, 100].", ge=-1, le=101)

    def __iter__(self):
        return iter((self.l, self.r, self.value))

    def unpack(self) -> tuple[int, int, float]:
        return self.l, self.r, self.value

    @staticmethod
    def from_iterable(x: Iterable):
        l, r, value = x
        return Segment(l=l, r=r, value=value)

    def __len__(self):
        return self.r - self.l + 1


class GradeElement(GradeBase):
    """
    Grade element stored in db and consumed by client. The values are between 0~100.
    """

    segments: list[Segment] = Field(
        description="A list of segments. The segments are expected to be disjoint, and taking up the whole [0, 9] range. The sum is expected to be (nearly) 100."
    )
    id: Annotated[str, Field(min_length=16, max_length=16)] = Field(
        default="", description="A string generated by backend server."
    )

    def __init__(self, **data):
        super().__init__(**data)
        self.id = self.get_id()

    def get_id(self):
        return hashlib.sha256(
            repr((self.course.id1, self.class_id, self.semester, self.class_id)).encode()
        ).hexdigest()[:16]

    @field_validator("segments")
    def valiadte_grade_eles(cls, v: list[Segment]):
        if not math.isclose(sum(grade.value for grade in v), 100, abs_tol=1):
            raise Exception(f"sum = {sum(grade.value for grade in v)}")
        for i in range(len(v) - 1):
            assert v[i].r + 1 == v[i + 1].l, v
        return v

    model_config = {
        "json_schema_extra": {
            "examples": [
                {
                    "course_id1": "CSIE1212",
                    "semester": "110-2",
                    "lecturer": "æž—è»’ç”°",
                    "class_id": "01",
                    "segments": [{"l": 0, "r": 8, "value": 91}, {"l": 9, "r": 9, "value": 9}],
                    "id": -1,
                }
            ]
        }
    }


# ----------------------------------- Query ---------------------------------- #

QUERY_FIELDS = ("id1", "id2", "title")
# QueryField: TypeAlias = Literal["id1", "id2", "title"]
QUERY_FILTERS = ("class_id", "semester")
# QueryFilter: TypeAlias = Literal["class_id", "semester"]


class QueryCourse(BaseModel):
    """
    Partial of `Course`.
    """

    id1: Id1 = Field(default="", validate_default=False)
    id2: Id2 = Field(default="", validate_default=False)
    title: str = ""


class QueryFilter(BaseModel):
    """
    Additinoal filters for querying grades.
    """

    class_id: str = ""
    semester: Semester = Field(default="111-1", validate_default=False)


# ----------------------------------- Page ----------------------------------- #


class Page(BaseModel):
    """
    Page submitted by user.
    """

    content: str = Field(description="The html content of user's grade page.")
    hashCode: int = Field(description="Hashed value of `content`.")

    # TODO: use base64 to encode content
    # @field_validator("content")
    # @classmethod
    # def parse_content(cls, v: bytes):
    #     return base64.decodebytes(v)

    @staticmethod
    def get_hash_code(content: str):
        """
        Generate hashcode for page content.
        """

        MAGIC = "TH3_M5G1C_OF_NTU" * 3
        magic_idx = []
        cur = 0
        for m in MAGIC:
            cur += ord(m)
            cur %= len(content)
            magic_idx.append(cur)

        h = 0
        a = []
        for c in [content[idx] for idx in magic_idx]:
            a.append(ord(c))
            h = (h << 5) - h + ord(c)

            h &= 1 << 63 - 1
        return h

    @model_validator(mode="after")
    def validate_hash(self):
        if self.hashCode != self.get_hash_code(self.content):
            raise RequestValidationError([])
        return self


# ----------------------------------- User ----------------------------------- #


def validate_student_id(id: str):
    if re.match(r"[a-zA-Z0-9]{9}", id):
        return id.capitalize()
    raise RequestValidationError([])  # TODO: is this error suitable?


StudentId = Annotated[
    str, Field(description="A student's id, e.g. b10401006."), AfterValidator(validate_student_id)
]
